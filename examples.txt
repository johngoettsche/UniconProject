ALTERNATION
(or)

SNOBOL4:
Var = A | B

Unicon Patterns:
Var := A .| B

Unicon Alternation:
Var := A | B

Unicon Repeated Alternation:
Var := |A

Thoughts:  If it is possible to use | for alternation, then it would be preferable to do so for consistency sake, but when should Unicon default to string scanning and when does it default to patterns?

--------------------------------
CONCATENATION
(and)

SNOBOL4:
Var = A B

Unicon Patterns:
Var := A && B

Unicon Strings:
Var := A || B

Unicon Lists:
Var := A ||| B

Thoughts:  Implicit concatenation may be nice, but are there reduce-reduce issues with the grammar?  If it is possible to use || for concatenation, then it would be preferable to do so for consistency sake, but when should Unicon default to string scanning and when does it default to patterns?

--------------------------------
PATTERN EVALUATION
(and)

SNOBOL4:
line  pattern

Unicon Patterns:
line ?? pattern

Unicon String Scanning:
line ? expr

Thoughts:  Do we need to differnt opperators for patterns and strings?  It would be nice to use ? for both, but when should Unicon default to string scanning and when does it default to patterns?

--------------------------------
MATCHING/SCANNING PROCESS

SNOBOL4:
'Reads'  ('B' | 'R') ('e' | 'ea') ('d' | 'ds')

Unicon Patterns:
"Reads" ?? ("B" .| "R") && ("e" .| "ea") && ("d" .| "ds")

 R e a d s		-> "B"	   "e"	   "d"
^					   "R"	   "ea"	   "ds"

 R e a d s		   "B"	   "e"	   "d"
^					-> "R"	   "ea"	   "ds"

 R e a d s		   "B"	-> "e"	   "d"
  ^				---"R"-	   "ea"	   "ds"
  
 R e a d s		   "B"	---"e"-	-> "d"
    ^ 			---"R"-	   "ea"	   "ds"		
	 
 R e a d s		   "B"	---"e"-	   "d"
    ^ 			---"R"-	   "ea"	-> "ds"
	 
 R e a d s		   "B"		"e" 		"d"
    ^ 			---"R"-	-> "ea"	   "ds"

 R e a d s		   "B"	   "e" 	-> "d"
      ^			---"R"-	---"ea"-	   "ds"
		
 R e a d s		   "B"	   "e" 	-> "d"
        ^		---"R"-	---"ea"-	   "ds"
		  
 R e a d s		   "B"	   "e" 	---"d"-
        *		---"R"-	---"ea"-	   "ds"
		  
MATCHES: Read
The left operand of the .| operator is checked first, therefore, this pattern will not match reads, as it succeeds when it checks the "d".  It would have to fail on checking "d" to move oo to checking "ds".  In order to have the pattern succeed on both "d" or "ds", "ds" would have to be the left operand, as "d" is a substring of "ds".

--------------------------------
VARIABLE ASSIGNMENT

SNOBOL4:
line = 'Reads'
pattern = ('B' | 'R') ('e' | 'ea') ('d' | 'ds')
line  pattern

Unicon:
line := "Reads"
pattern := ("B" .| "R") && ("e" .| "ea") && ("d" .| "ds")
line ?? pattern

MATCHES: Read

Thoughts:  := is consistent with Unicon. 
--------------------------------
CONDITIONAL ASSIGNMENT

SNOBOL4:
pattern = ('B' | 'R') . Var

Unicon:
pattern := ("B" .| "R") -> Var

Result:
Var = B or R if overall pattern is successful

Thoughts:  I find -> to graphically illiterates its purpose while the . to be a bit confusing. 

--------------------------------
IMMEDIATE ASSIGNMENT

SNOBOL4:
pattern = ('B' | 'R') $ Var

Unicon:
pattern := ("B" .| "R") $$ Var

Result:
Var = B or R when matched even if overall pattern fails

Thoughts:  I find $$ graphically not consistent with the conditional assignment operator, how about $> for immediate assignment resulting is -> $> and .> for assignments?  This is a minor issue that I am sensitive to because of my art and cartography background.

--------------------------------
CURSOR ASSIGNMENT

SNOBOL4:
line = 'the beads are red'
p = ('b' | 'r') ('e' | 'ea') ('d' | 's')
pattern = @x p @y
line  pattern

Unicon:
line := "the beads are red"
p := ("b" .| "r") && ("e" .| "ea") && ("d" .| "ds")
pattern := .$ x && p && .$ y
line ?? pattern

Result:
x = 5
y = 9

Thoughts:  I find .$ graphically not consistent with the conditional assignment operator, .> for cursor or &pos assignment resulting is -> $> and .> for assignments?  This is a minor issue that I am sensitive to because of my art and cartography background.

--------------------------------
REPLACEMENT STATEMENT

SNOBOL4:
word = 'GIRD'
word  'I' = 'OU'

Unicon:
word := "GIRD"
word ?? "I" := "OU"

result:
word = GOURD

Thoughts:  This actually works, but I am not sure why.

--------------------------------
LEN(n)/PLen(n)

SNOBOL4:
line = '1966 AUG. 09 John'
dateOfBirth = LEN(4) . YR ' ' LEN(4) . MO ' ' LEN(2) . DAY
line  dateOfBirth

Unicon Patterns:
line := "1966 AUG. 09 John"
dateOfBirth := PLen(4) $$ YR && " " && PLen(4) $$ MO && " " && PLen(2) $$ DAY 
line ?? dateOfBirth

Unicon Strings:
line := "1966 AUG. 09 John"
line ? {
	YR := move(4)
	move(1)
	MO := move(4)
	move(1)
	DAY := move(2)
}

result:
YR = 1966
MO = AUG.
DAY = 09

Thoughts:  I find the P at the beginning of every built-in function to be annoying.  Len() or len() do not appear to be used, so would it make more sense to use one of those?  

--------------------------------
SPAN()/PSpan()

SNOBOL4:
line = "1966 AUG. 09 John"
line  SPAN('0123456789') . year

Unicon Patterns:
line := "1966 AUG. 09 John"
line ?? PSpan(&digits) -> year

Unicon Strings:
line := "1966 AUG. 09 John"
line ? year := tab(many(&digits))

result:
year = 1966

Thoughts:  I find the P at the beginning of every built-in function to be annoying.  Span() or span() do not appear to be used, so would it make more sense to use one of those?

--------------------------------
BREAK()/PBreak()

SNOBOL4:
line = "1966 AUG. 09 John"
line  BREAK(' ') . year

Unicon Patterns:
line := "1966 AUG. 09 John"
line ?? PBreak(' ') -> year

Unicon Strings:
line := "1966 AUG. 09 John"
line ? year := tab(upto(' '))

result:
year = 1966

Thoughts:  I find the P at the beginning of every built-in function to be annoying.  break is already used, but Break is not, so should we use Break() instead of PBreak()?  If we do, for consistency sake we might want to start the pattern built in functions with a capital letter.

--------------------------------
ANY()/PAny()

SNOBOL4:
vowels = ANY('aeiou')
line = 'def'
line  vowels . result

Unicon Patterns:
vowels := PAny('aeiou')
line := "def"
line ?? vowels -> result

Unicon Strings:
vowels := 'aeiou'
line := "def"
line ? {
	tab(upto(vowels))
	result := move(1)
}
result:
result = e

Thoughts:  I find the P at the beginning of every built-in function to be annoying.  any is already used, but Any is not, so should we use Any() instead of PBreak()?  If we do, for consistency sake we might want to start the pattern built in functions with a capital letter.

--------------------------------
NOTANY()/PNotAny()

SNOBOL4:
cons = NOTANY('aeiou')
line = 'abcdef'
line  cons . result

Unicon Patterns:
cons := PNotAny('aeiou')
line := "abcdef"
line ?? cons -> result

Unicon Strings:
vowels := 'aeiou'
cons := &letters -- vowels
line := "abcdef"
line ? {
	tab(upto(cons))
	result := move(1)
}
result:
result = b

Thoughts:  I find the P at the beginning of every built-in function to be annoying.  NotAny() or notany() do not appear to be used, so would it make more sense to use one of those?
--------------------------------
TAB()/PTab()

SNOBOL4:
'SNOBOL4'  LEN(2) TAB(6) . result

Unicon Patterns:
"SNOBOL4" ?? PLen(2) && PTab(6) -> result

Unicon Strings:
"SNOBOL4" ? {
	move(2)
	result := tab(6)
}

result:
result = OBO

Thoughts:  I find the P at the beginning of every built-in function to be annoying.  pattern matching cursor position and string scanning &pos are similar but not necessarily consistent.  It would make sense to use the string scanning &pos if that is possible.  If not, then the Tab() could use negative index numbers instead of positive index numbers for RTab().  It would be nice to have these be consistent with string scanning.

--------------------------------
RTAB()/PRtab()

SNOBOL4:
'SNOBOL4'  LEN(2) RTAB(1) . result

Unicon Patterns:
"SNOBOL4" ?? PLen(2) && PRtab(1) -> result

Unicon Strings:
"SNOBOL4" ? {
	move(2)
	result := tab(-1)
}

result:
result = OBOL

Thoughts:  pattern matching cursor position and string scanning &pos are similar but not necessarily consistent.  It would make sense to use the string scanning &pos if that is possible.  If not, then the Tab() could use negative index numbers instead of positive index numbers for RTab().  It would be nice to have these be consistent with string scanning.

--------------------------------
REM()/PRest()

SNOBOL4:
'SNOBOL4'  LEN(2) REM . result

Unicon Patterns:
"SNOBOL4" ?? PLen(2) && PRest() -> result

Unicon Strings:
"SNOBOL4" ? {
	move(2)
	result := tab(0)
}

result:
result = OBOL4

Thoughts:  Rest() or rest() do not appear to be used, so would it make more sense to use one of those?

--------------------------------
POS()/PPos()

SNOBOL4:
'SNOBOL4'  POS(2) REM . result

Unicon Patterns:
"SNOBOL4" ?? PPos(2) && PRest() -> result

Unicon Strings:
"SNOBOL4" ? {
	&pos := 2
	result := tab(0)
}

result:
result = NOBOL4

Thoughts:  pattern matching cursor position and string scanning &pos are similar but not necessarily consistent.  It would make sense to use the string scanning &pos if that is possible.  If not, then the Pos() could use negative index numbers instead of positive index numbers for Rpos().  It would be nice to have these be consistent.

--------------------------------
RPOS()/PRpos()

SNOBOL4:
'SNOBOL4'  RPOS(4) REM . result

Unicon Patterns:
"SNOBOL4" ?? PRpos(4) && PRest() -> result

Unicon Strings:
"SNOBOL4" ? {
	&pos := -4
	result := tab(0)
}

result:
result = BOL4

Thoughts:  pattern matching cursor position and string scanning &pos are similar but not necessarily consistent.  It would make sense to use the string scanning &pos if that is possible.  If not, then the Pos() could use negative index numbers instead of positive index numbers for Rpos().  It would be nice to have these be consistent.  Currently pos(i) checks to see if the current position is at i.

--------------------------------
FAIL/PFail()

SNOBOL4:
'MISSISSIPPI'  ('IS' | 'SI' | 'IP' | 'PI') $ OUTPUT FAIL

Unicon Patterns:
out := &output
"MISSISSIPPI" ?? ("IS" .| "SI" .| "IP" .| "PI") $$ out && PFail()

result:
IS
SI
IS
SI
IP
PI

Thoughts:  I find the P at the beginning of every built-in function to be annoying.  fail is already used, but Fail is not, so should we use Fail() instead of PFail()?  If we do, for consistency sake we might want to start the pattern built in functions with a capital letter.

--------------------------------
FENCE/PFence()

SNOBOL4:
&ANCHOR = 1
'BERATES'  ('BE' | 'GE' | 'FRE') FENCE ('TS' | 'T')

Unicon Patterns:
out := &output
"BERATES" ?? (("BE" .| "RA" .| "FRE") && PFence() &&("TES" | "T")) -> out

result:
-fails-  it finds "BE" and then is unable to match "TES" or "T" immediately after, when tries to backtrack to try "RA" it hits the PFence() and fails.  If PFence() was not there then it would match "RATES".

Thoughts:  I find the P at the beginning of every built-in function to be annoying.  Fence() and fence() are not, so should we use one of them instead of PFail()? 

--------------------------------
ABORT/PCancel()

SNOBOL4:
line = 'testline'
pattern =  'li' ABORT | 'ne'
line  pattern

Unicon Patterns:
line := "testline"
pattern :=  "li" && PCancel() .| "ne"
line ?? pattern

result:
-fails-  when it finds "li" PCancel() makes the pattern cancel its operation and return a failure.  If the "ne" as changed to something that appears before "li" then it would succeed with that substring.

Thoughts:  I find the P at the beginning of every built-in function to be annoying.  Cancel() and cancel() are not, so should we use one of them instead of PCancel()? 

--------------------------------
ARB/PArb()

SNOBOL4:
line = 'testline'
pattern =  'es' ARB 'in'
line  pattern

Unicon Patterns:
line := "testline"
pattern :=  "es" && PArb() && "in"
line ?? pattern

result:
estlin

Thoughts:  I find the P at the beginning of every built-in function to be annoying.  Arb() and arb() are not, so should we use one of them instead of PArb()? 

--------------------------------
ARBNO/PArbno()

SNOBOL4:
item = span('0123456789')
pattern := PPos(1) && item && PArbno(',' && item)

Unicon Patterns:
out := &output
item := PSpan(&digits)
pattern := PPos(1) && item && PArbno("," && item)
if "12,234" ?? pattern then write("Match succeeded")
else write("Match Failed")
if "12,,234" ?? pattern then write("Match succeeded")
else write("Match Failed")

result:
Match succeeded
Match succeeded(this one should fail)

Thoughts:  Something is not working with PArbno().  After playing around with it I found that is is not making a pattern or substring, and is returning a success.  

--------------------------------
BAL/PBal()

SNOBOL4:
line = '(A + B) + C'
line2 = ')A + B( + C'
pattern =  BAL $ OUTPUT
line  pattern
line2  pattern

Unicon Patterns:
out := &output
line := "(A + B) + C"
line2 := ")A + B( + C"
pattern :=  PBal() $$ out
line ?? pattern
line2 ?? pattern

Unicon Strings:
line := "(A + B) + C"
line2 := ")A + B( + C"
write(line ? bal())
write(line2 ? bal())

result:
(A + B)
A

unicon strings result:
1
1

Thoughts:  I find the P at the beginning of every built-in function to be annoying.  bal is used and Bal() is not, so should we use Bal() of them instead of PBal()? 

--------------------------------
UNEVALUATED EXPRESSIONS

SNOBOL4:
n = 8
line = 'abcdefghij'
pattern := POS(*n) && REM
line  pattern . OUTPUT
n = 4
line  pattern . OUTPUT

Unicon Patterns:
n := 8
out := &output
line := "abcdefghij"
pattern := PPos(`n`) && PRest()
line ?? pattern -> out
n := 4
line ?? pattern -> out

Unicon strings:
n := 8
line := "abcdefghij"
write(line[n:0])
n := 4
write(line[n:0])

result:
hij
defghij

Thoughts:  

--------------------------------
Anchored Mode: the pattern much succeed starting with the first character in the string.  This is not implemented in Unicon Patterns.

Thoughts:  The ? operator in string scanning sets the scan at the beginning of the string.  If we do adapt the ? operator to handle pattern matching, it would be consistent implement it using the Anchored mode restriction.

--------------------------------
Non-Anchored Mode: the pattern can match at any starting location in the string.  This is the standard mode used in Unicon Patterns.

--------------------------------
Quickscan Mode: In this method, each bead is assigned a number for the shortest lenth of a matched substring if the bead is selected.  If this number is greater than the number of charcters left in the string then it will not be checked.  

"Reads" ?? ("B" .| "R") && ("e" .| "ea") && ("d" .| "ds")

 R e d (3)		-> "B"(3)	   "ea"(3)	   "ds"(2)
^					   "R"(3)	   "e"(2)	   "d"(1)

 R e d (3)		   "B"(3)	   "ea"(3)	   "ds"(2)
^					-> "R"(3)	   "e"(2)	   "d"(1)

 R e d (2)		   "B"(3)	   "ea"(3)x	   "ds"(2)
  ^				---"R"(3)-	-> "e"(2)	   "d"(1)
  
 R e d (1)		   "B"(3)	   "ea"(3)	   "ds"(2)x
	 ^				---"R"(3)-	---"e"(2)-	-> "d"(1)	
	 
 R e d (0)		   "B"(3)	   "ea"(3)	   "ds"(2)x
	 	*			---"R"(3)-	---"e"(2)-	---"d"(1)-

Thoughts:  I need to look at the ?? operator to see if this method is implemented in Unicon Patterns.  If it is not, then it might help with efficiency.
		
--------------------------------	
Fullscan Mode: This is the standard method of pattern matching.  It is less efficient than the Quickscan Mode as it will check all possible beans without regard to whether it is possible to used that bean as a part of the resulting substring.